/******************************************************************************
 *  
 * This program is free software; you can redistribute it and/or modify it 
 * under the terms of the GNU General Public License as published by the Free 
 * Software Foundation; either version 3 of the License, or (at your option) 
 * any later version.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT 
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for 
 * more details.
 * 
 * You should have received a copy of the GNU General Public License along with 
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * Author     : Jerome Fuselier
 * Creation   : January 2011
 *  
 *****************************************************************************/

package uk.ac.liv.ffmpeg.libavcodec;

import uk.ac.liv.ffmpeg.libavcodec.AVCodec.AVAudioServiceType;
import uk.ac.liv.ffmpeg.libavcodec.AVCodec.AVChromaLocation;
import uk.ac.liv.ffmpeg.libavcodec.AVCodec.AVColorPrimaries;
import uk.ac.liv.ffmpeg.libavcodec.AVCodec.AVColorRange;
import uk.ac.liv.ffmpeg.libavcodec.AVCodec.AVColorSpace;
import uk.ac.liv.ffmpeg.libavcodec.AVCodec.AVColorTransferCharacteristic;
import uk.ac.liv.ffmpeg.libavcodec.AVCodec.AVDiscard;
import uk.ac.liv.ffmpeg.libavcodec.AVCodec.Motion_Est_ID;
import uk.ac.liv.ffmpeg.libavutil.AVClass;
import uk.ac.liv.ffmpeg.libavutil.AVOption;
import uk.ac.liv.ffmpeg.libavutil.AVOptionValue;
import uk.ac.liv.ffmpeg.libavutil.AVOption.AVOptionType;
import uk.ac.liv.ffmpeg.libavutil.AVUtil;
import uk.ac.liv.ffmpeg.libavutil.SampleFmt.AVSampleFormat;

public class Options {
	
	static final AVOptionType OTI = AVOptionType.FF_OPT_TYPE_INT;
	static final AVOptionType OTF = AVOptionType.FF_OPT_TYPE_FLAGS;
	static final AVOptionType OTC = AVOptionType.FF_OPT_TYPE_CONST;
	static final AVOptionType OTR = AVOptionType.FF_OPT_TYPE_RATIONAL;
	static final AVOptionType OTFl = AVOptionType.FF_OPT_TYPE_FLOAT;
	static final AVOptionType OTS = AVOptionType.FF_OPT_TYPE_STRING;
	static final AVOptionType OTI64 = AVOptionType.FF_OPT_TYPE_INT64;
	static final AVOptionType OTE = AVOptionType.FF_OPT_TYPE_ENUM;
	
	static final int V = AVOption.AV_OPT_FLAG_VIDEO_PARAM;
	static final int A = AVOption.AV_OPT_FLAG_AUDIO_PARAM;
	static final int S = AVOption.AV_OPT_FLAG_SUBTITLE_PARAM;
	static final int E = AVOption.AV_OPT_FLAG_ENCODING_PARAM;
	static final int D = AVOption.AV_OPT_FLAG_DECODING_PARAM;
	

	static final int DEFAULT = 0; //should be NAN 
	
	static final int MIN = Integer.MIN_VALUE;
	static final int MAX = Integer.MAX_VALUE;
	static final float FLT_MAX = Float.MAX_VALUE;
	static final float FLT_MIN = Float.MIN_VALUE;
	static final int CHAR_MIN = Character.MIN_VALUE;
	static final int CHAR_MAX = Character.MAX_VALUE;
	static final int UINT_MAX = Integer.MAX_VALUE;
	static final double INT64_MAX = Long.MAX_VALUE;
	static final double INT64_MIN = Long.MIN_VALUE;
	
	static final int AV_CODEC_DEFAULT_BITRATE = 200*1000;
	

	public static void add_default_options(AVClass cls) {
				
		cls.add_option(new AVOption("b", "set bitrate (in bits/s)", "bit_rate", OTI, new AVOptionValue(AV_CODEC_DEFAULT_BITRATE), MIN, MAX, V|E));
		cls.add_option(new AVOption("ab", "set bitrate (in bits/s)", "bit_rate", OTI, new AVOptionValue(64*1000), MIN, MAX, A|E));
		cls.add_option(new AVOption("bt", "set video bitrate tolerance (in bits/s)", "bit_rate_tolerance", OTI, new AVOptionValue(AV_CODEC_DEFAULT_BITRATE*20), 1, MAX, V|E));
		cls.add_option(new AVOption("flags", null, "flags", OTF, new AVOptionValue(DEFAULT), 0, MAX, V|A|E|D, "flags"));
		cls.add_option(new AVOption("mv4", "use four motion vector by macroblock (mpeg4)", null, OTC, new AVOptionValue(AVCodec.CODEC_FLAG_4MV), MIN, MAX, V|E, "flags"));
		cls.add_option(new AVOption("obmc", "use overlapped block motion compensation (h263+)", null, OTC, new AVOptionValue(AVCodec.CODEC_FLAG_OBMC), MIN, MAX, V|E, "flags"));
		cls.add_option(new AVOption("qpel", "use 1/4 pel motion compensation", null, OTC, new AVOptionValue(AVCodec.CODEC_FLAG_QPEL), MIN, MAX, V|E, "flags"));
		cls.add_option(new AVOption("loop", "use loop filter", null, OTC, new AVOptionValue(AVCodec.CODEC_FLAG_LOOP_FILTER), MIN, MAX, V|E, "flags"));
		cls.add_option(new AVOption("qscale", "use fixed qscale", null, OTC, new AVOptionValue(AVCodec.CODEC_FLAG_QSCALE), MIN, MAX, 0, "flags"));
		cls.add_option(new AVOption("gmc", "use gmc", null, OTC, new AVOptionValue(AVCodec.CODEC_FLAG_GMC), MIN, MAX, V|E, "flags"));
		cls.add_option(new AVOption("mv0", "always try a mb with mv=<0,0>", null, OTC, new AVOptionValue(AVCodec.CODEC_FLAG_MV0), MIN, MAX, V|E, "flags"));
		cls.add_option(new AVOption("part", "use data partitioning", null, OTC, new AVOptionValue(AVCodec.CODEC_FLAG_PART), MIN, MAX, V|E, "flags"));
		cls.add_option(new AVOption("input_preserved", null, null, OTC, new AVOptionValue(AVCodec.CODEC_FLAG_INPUT_PRESERVED), MIN, MAX, 0, "flags"));
		cls.add_option(new AVOption("pass1", "use internal 2pass ratecontrol in first  pass mode", null, OTC, new AVOptionValue(AVCodec.CODEC_FLAG_PASS1), MIN, MAX, 0, "flags"));
		cls.add_option(new AVOption("pass2", "use internal 2pass ratecontrol in second pass mode", null, OTC, new AVOptionValue(AVCodec.CODEC_FLAG_PASS2), MIN, MAX, 0, "flags"));
		cls.add_option(new AVOption("extern_huff", "use external huffman table (for mjpeg)", null, OTC, new AVOptionValue(AVCodec.CODEC_FLAG_EXTERN_HUFF), MIN, MAX, 0, "flags"));
		cls.add_option(new AVOption("gray", "only decode/encode grayscale", null, OTC, new AVOptionValue(AVCodec.CODEC_FLAG_GRAY), MIN, MAX, V|E|D, "flags"));
		cls.add_option(new AVOption("emu_edge", "don't draw edges", null, OTC, new AVOptionValue(AVCodec.CODEC_FLAG_EMU_EDGE), MIN, MAX, 0, "flags"));
		cls.add_option(new AVOption("psnr", "error[?] variables will be set during encoding", null, OTC, new AVOptionValue(AVCodec.CODEC_FLAG_PSNR), MIN, MAX, V|E, "flags"));
		cls.add_option(new AVOption("truncated", null, null, OTC, new AVOptionValue(AVCodec.CODEC_FLAG_TRUNCATED), MIN, MAX, 0, "flags"));
		cls.add_option(new AVOption("naq", "normalize adaptive quantization", null, OTC, new AVOptionValue(AVCodec.CODEC_FLAG_NORMALIZE_AQP), MIN, MAX, V|E, "flags"));
		cls.add_option(new AVOption("ildct", "use interlaced dct", null, OTC, new AVOptionValue(AVCodec.CODEC_FLAG_INTERLACED_DCT), MIN, MAX, V|E, "flags"));
		cls.add_option(new AVOption("low_delay", "force low delay", null, OTC, new AVOptionValue(AVCodec.CODEC_FLAG_LOW_DELAY), MIN, MAX, V|D|E, "flags"));
		cls.add_option(new AVOption("alt", "enable alternate scantable (mpeg2/mpeg4)", null, OTC, new AVOptionValue(AVCodec.CODEC_FLAG_ALT_SCAN), MIN, MAX, V|E, "flags"));
		cls.add_option(new AVOption("global_header", "place global headers in extradata instead of every keyframe", null, OTC, new AVOptionValue(AVCodec.CODEC_FLAG_GLOBAL_HEADER), MIN, MAX, V|A|E, "flags"));
		cls.add_option(new AVOption("bitexact", "use only bitexact stuff (except (i)dct)", null, OTC, new AVOptionValue(AVCodec.CODEC_FLAG_BITEXACT), MIN, MAX, A|V|S|D|E, "flags"));
		cls.add_option(new AVOption("aic", "h263 advanced intra coding / mpeg4 ac prediction", null, OTC, new AVOptionValue(AVCodec.CODEC_FLAG_AC_PRED), MIN, MAX, V|E, "flags"));
		cls.add_option(new AVOption("umv", "use unlimited motion vectors", null, OTC, new AVOptionValue(AVCodec.CODEC_FLAG_H263P_UMV), MIN, MAX, V|E, "flags"));
		cls.add_option(new AVOption("cbp", "use rate distortion optimization for cbp", null, OTC, new AVOptionValue(AVCodec.CODEC_FLAG_CBP_RD), MIN, MAX, V|E, "flags"));
		cls.add_option(new AVOption("qprd", "use rate distortion optimization for qp selection", null, OTC, new AVOptionValue(AVCodec.CODEC_FLAG_QP_RD), MIN, MAX, V|E, "flags"));
		cls.add_option(new AVOption("aiv", "h263 alternative inter vlc", null, OTC, new AVOptionValue(AVCodec.CODEC_FLAG_H263P_AIV), MIN, MAX, V|E, "flags"));
		cls.add_option(new AVOption("slice", null, null, OTC, new AVOptionValue(AVCodec.CODEC_FLAG_H263P_SLICE_STRUCT), MIN, MAX, V|E, "flags"));
		cls.add_option(new AVOption("ilme", "interlaced motion estimation", null, OTC, new AVOptionValue(AVCodec.CODEC_FLAG_INTERLACED_ME), MIN, MAX, V|E, "flags"));
		cls.add_option(new AVOption("scan_offset", "will reserve space for svcd scan offset user data", null, OTC, new AVOptionValue(AVCodec.CODEC_FLAG_SVCD_SCAN_OFFSET), MIN, MAX, V|E, "flags"));
		cls.add_option(new AVOption("cgop", "closed gop", null, OTC, new AVOptionValue(AVCodec.CODEC_FLAG_CLOSED_GOP), MIN, MAX, V|E, "flags"));
		cls.add_option(new AVOption("fast", "allow non spec compliant speedup tricks", null, OTC, new AVOptionValue(AVCodec.CODEC_FLAG2_FAST), MIN, MAX, V|E, "flags2"));
		cls.add_option(new AVOption("sgop", "strictly enforce gop size", null, OTC, new AVOptionValue(AVCodec.CODEC_FLAG2_STRICT_GOP), MIN, MAX, V|E, "flags2"));
		cls.add_option(new AVOption("noout", "skip bitstream encoding", null, OTC, new AVOptionValue(AVCodec.CODEC_FLAG2_NO_OUTPUT), MIN, MAX, V|E, "flags2"));
		cls.add_option(new AVOption("local_header", "place global headers at every keyframe instead of in extradata", null, OTC, new AVOptionValue(AVCodec.CODEC_FLAG2_LOCAL_HEADER), MIN, MAX, V|E, "flags2"));
		cls.add_option(new AVOption("sub_id", null, "sub_id", OTI, new AVOptionValue(DEFAULT), MIN, MAX));
		cls.add_option(new AVOption("me_method", "set motion estimation method", "me_method", OTE, new AVOptionValue(Motion_Est_ID.ME_EPZS), MIN, MAX, V|E, "me_method"));
		cls.add_option(new AVOption("zero", "zero motion estimation (fastest)", null, OTC, new AVOptionValue(Motion_Est_ID.ME_ZERO), MIN, MAX, V|E, "me_method"));
		cls.add_option(new AVOption("full", "full motion estimation (slowest)", null, OTC, new AVOptionValue(Motion_Est_ID.ME_FULL), MIN, MAX, V|E, "me_method"));
		cls.add_option(new AVOption("epzs", "EPZS motion estimation (default)", null, OTC, new AVOptionValue(Motion_Est_ID.ME_EPZS), MIN, MAX, V|E, "me_method"));
		cls.add_option(new AVOption("esa", "esa motion estimation (alias for full)", null, OTC, new AVOptionValue(Motion_Est_ID.ME_FULL), MIN, MAX, V|E, "me_method"));
		cls.add_option(new AVOption("tesa", "tesa motion estimation", null, OTC, new AVOptionValue(Motion_Est_ID.ME_TESA), MIN, MAX, V|E, "me_method"));
		cls.add_option(new AVOption("dia", "dia motion estimation (alias for epzs)", null, OTC, new AVOptionValue(Motion_Est_ID.ME_EPZS), MIN, MAX, V|E, "me_method"));
		cls.add_option(new AVOption("log", "log motion estimation", null, OTC, new AVOptionValue(Motion_Est_ID.ME_LOG), MIN, MAX, V|E, "me_method"));
		cls.add_option(new AVOption("phods", "phods motion estimation", null, OTC, new AVOptionValue(Motion_Est_ID.ME_PHODS), MIN, MAX, V|E, "me_method"));
		cls.add_option(new AVOption("x1", "X1 motion estimation", null, OTC, new AVOptionValue(Motion_Est_ID.ME_X1), MIN, MAX, V|E, "me_method"));
		cls.add_option(new AVOption("hex", "hex motion estimation", null, OTC, new AVOptionValue(Motion_Est_ID.ME_HEX), MIN, MAX, V|E, "me_method"));
		cls.add_option(new AVOption("umh", "umh motion estimation", null, OTC, new AVOptionValue(Motion_Est_ID.ME_UMH), MIN, MAX, V|E, "me_method"));
		cls.add_option(new AVOption("iter", "iter motion estimation", null, OTC, new AVOptionValue(Motion_Est_ID.ME_ITER), MIN, MAX, V|E, "me_method"));
//		cls.add_option(new AVOption("extradata_size", null, "extradata_size", OTI, new AVOptionValue(DEFAULT), MIN, MAX));
		cls.add_option(new AVOption("time_base", null, "time_base", OTR, new AVOptionValue(Double.valueOf(0)), MIN, MAX));
		cls.add_option(new AVOption("g", "set the group of picture size", "gop_size", OTI, new AVOptionValue(12), MIN, MAX, V|E));
		cls.add_option(new AVOption("ar", "set audio sampling rate (in Hz)", "sample_rate", OTI, new AVOptionValue(DEFAULT), MIN, MAX));
		cls.add_option(new AVOption("ac", "set number of audio channels", "channels", OTI, new AVOptionValue(DEFAULT), MIN, MAX));
		cls.add_option(new AVOption("cutoff", "set cutoff bandwidth", "cutoff", OTI, new AVOptionValue(DEFAULT), MIN, MAX, A|E));
		cls.add_option(new AVOption("frame_size", null, "frame_size", OTI, new AVOptionValue(DEFAULT), MIN, MAX, A|E));
		cls.add_option(new AVOption("frame_number", null, "frame_number", OTI, new AVOptionValue(DEFAULT), MIN, MAX));
		cls.add_option(new AVOption("delay", null, "delay", OTI, new AVOptionValue(DEFAULT), MIN, MAX));
		cls.add_option(new AVOption("qcomp", "video quantizer scale compression (VBR)", "qcompress", OTFl, new AVOptionValue(Float.valueOf((float)0.5)), -FLT_MAX, FLT_MAX, V|E));
		cls.add_option(new AVOption("qblur", "video quantizer scale blur (VBR)", "qblur", OTFl, new AVOptionValue(Float.valueOf((float)0.5)), 0, FLT_MAX, V|E));
		cls.add_option(new AVOption("qmin", "min video quantizer scale (VBR)", "qmin", OTI, new AVOptionValue(2), 0, 69, V|E));
		cls.add_option(new AVOption("qmax", "max video quantizer scale (VBR)", "qmax", OTI, new AVOptionValue(31), 0, 69, V|E));
		cls.add_option(new AVOption("qdiff", "max difference between the quantizer scale (VBR)", "max_qdiff", OTI, new AVOptionValue(3), MIN, MAX, V|E));
		cls.add_option(new AVOption("bf", "use 'frames' B frames", "max_b_frames", OTI, new AVOptionValue(DEFAULT), 0, AVCodec.FF_MAX_B_FRAMES, V|E));
		cls.add_option(new AVOption("b_qfactor", "qp factor between p and b frames", "b_quant_factor", OTFl, new AVOptionValue(Float.valueOf((float)1.25)), -FLT_MAX, FLT_MAX, V|E));
//		cls.add_option(new AVOption("rc_strategy", "ratecontrol method", "rc_strategy", OTI, new AVOptionValue(DEFAULT), MIN, MAX, V|E));
		cls.add_option(new AVOption("b_strategy", "strategy to choose between I/P/B-frames", "b_frame_strategy", OTI, new AVOptionValue(0), MIN, MAX, V|E));
		cls.add_option(new AVOption("wpredp", "weighted prediction analysis method", "weighted_p_pred", OTI, new AVOptionValue(0), MIN, MAX, V|E));
		cls.add_option(new AVOption("ps", "rtp payload size in bytes", "rtp_payload_size", OTI, new AVOptionValue(DEFAULT), MIN, MAX, V|E));
		cls.add_option(new AVOption("mv_bits", null, "mv_bits", OTI, new AVOptionValue(DEFAULT), MIN, MAX));
		cls.add_option(new AVOption("header_bits", null, "header_bits", OTI, new AVOptionValue(DEFAULT), MIN, MAX));
		cls.add_option(new AVOption("i_tex_bits", null, "i_tex_bits", OTI, new AVOptionValue(DEFAULT), MIN, MAX));
		cls.add_option(new AVOption("p_tex_bits", null, "p_tex_bits", OTI, new AVOptionValue(DEFAULT), MIN, MAX));
		cls.add_option(new AVOption("i_count", null, "i_count", OTI, new AVOptionValue(DEFAULT), MIN, MAX));
		cls.add_option(new AVOption("p_count", null, "p_count", OTI, new AVOptionValue(DEFAULT), MIN, MAX));
		cls.add_option(new AVOption("skip_count", null, "skip_count", OTI, new AVOptionValue(DEFAULT), MIN, MAX));
		cls.add_option(new AVOption("misc_bits", null, "misc_bits", OTI, new AVOptionValue(DEFAULT), MIN, MAX));
		cls.add_option(new AVOption("frame_bits", null, "frame_bits", OTI, new AVOptionValue(DEFAULT), MIN, MAX));
		cls.add_option(new AVOption("codec_tag", null, "codec_tag", OTI, new AVOptionValue(DEFAULT), MIN, MAX));
		cls.add_option(new AVOption("bug", "workaround not auto detected encoder bugs", "workaround_bugs", OTI, new AVOptionValue(AVCodec.FF_BUG_AUTODETECT), MIN, MAX, V|D, "bug"));
		cls.add_option(new AVOption("autodetect", null, null, OTC, new AVOptionValue(AVCodec.FF_BUG_AUTODETECT), MIN, MAX, V|D, "bug"));
		cls.add_option(new AVOption("old_msmpeg4", "some old lavc generated msmpeg4v3 files (no autodetection)", null, OTC, new AVOptionValue(AVCodec.FF_BUG_OLD_MSMPEG4), MIN, MAX, V|D, "bug"));
		cls.add_option(new AVOption("xvid_ilace", "Xvid interlacing bug (autodetected if fourcc==XVIX)", null, OTC, new AVOptionValue(AVCodec.FF_BUG_XVID_ILACE), MIN, MAX, V|D, "bug"));
		cls.add_option(new AVOption("ump4", "(autodetected if fourcc==UMP4)", null, OTC, new AVOptionValue(AVCodec.FF_BUG_UMP4), MIN, MAX, V|D, "bug"));
		cls.add_option(new AVOption("no_padding", "padding bug (autodetected)", null, OTC, new AVOptionValue(AVCodec.FF_BUG_NO_PADDING), MIN, MAX, V|D, "bug"));
		cls.add_option(new AVOption("amv", null, null, OTC, new AVOptionValue(AVCodec.FF_BUG_AMV), MIN, MAX, V|D, "bug"));
		cls.add_option(new AVOption("ac_vlc", "illegal vlc bug (autodetected per fourcc)", null, OTC, new AVOptionValue(AVCodec.FF_BUG_AC_VLC), MIN, MAX, V|D, "bug"));
		cls.add_option(new AVOption("qpel_chroma", null, null, OTC, new AVOptionValue(AVCodec.FF_BUG_QPEL_CHROMA), MIN, MAX, V|D, "bug"));
		cls.add_option(new AVOption("std_qpel", "old standard qpel (autodetected per fourcc/version)", null, OTC, new AVOptionValue(AVCodec.FF_BUG_STD_QPEL), MIN, MAX, V|D, "bug"));
		cls.add_option(new AVOption("qpel_chroma2", null, null, OTC, new AVOptionValue(AVCodec.FF_BUG_QPEL_CHROMA2), MIN, MAX, V|D, "bug"));
		cls.add_option(new AVOption("direct_blocksize", "direct-qpel-blocksize bug (autodetected per fourcc/version)", null, OTC, new AVOptionValue(AVCodec.FF_BUG_DIRECT_BLOCKSIZE), MIN, MAX, V|D, "bug"));
		cls.add_option(new AVOption("edge", "edge padding bug (autodetected per fourcc/version)", null, OTC, new AVOptionValue(AVCodec.FF_BUG_EDGE), MIN, MAX, V|D, "bug"));
		cls.add_option(new AVOption("hpel_chroma", null, null, OTC, new AVOptionValue(AVCodec.FF_BUG_HPEL_CHROMA), MIN, MAX, V|D, "bug"));
		cls.add_option(new AVOption("dc_clip", null, null, OTC, new AVOptionValue(AVCodec.FF_BUG_DC_CLIP), MIN, MAX, V|D, "bug"));
		cls.add_option(new AVOption("ms", "workaround various bugs in microsofts broken decoders", null, OTC, new AVOptionValue(AVCodec.FF_BUG_MS), MIN, MAX, V|D, "bug"));
		cls.add_option(new AVOption("trunc", "trancated frames", null, OTC, new AVOptionValue(AVCodec.FF_BUG_TRUNCATED), MIN, MAX, V|D, "bug"));
		cls.add_option(new AVOption("lelim", "single coefficient elimination threshold for luminance (negative values also consider dc coefficient)", "luma_elim_threshold", OTI, new AVOptionValue(DEFAULT), MIN, MAX, V|E));
		cls.add_option(new AVOption("celim", "single coefficient elimination threshold for chrominance (negative values also consider dc coefficient)", "chroma_elim_threshold", OTI, new AVOptionValue(DEFAULT), MIN, MAX, V|E));
		cls.add_option(new AVOption("strict", "how strictly to follow the standards", "strict_std_compliance", OTI, new AVOptionValue(DEFAULT), MIN, MAX, A|V|D|E, "strict"));
		cls.add_option(new AVOption("very", "strictly conform to a older more strict version of the spec or reference software", null, OTC, new AVOptionValue(AVCodec.FF_COMPLIANCE_VERY_STRICT), MIN, MAX, V|D|E, "strict"));
		cls.add_option(new AVOption("strict", "strictly conform to all the things in the spec no matter what consequences", null, OTC, new AVOptionValue(AVCodec.FF_COMPLIANCE_STRICT), MIN, MAX, V|D|E, "strict"));
		cls.add_option(new AVOption("normal", null, null, OTC, new AVOptionValue(AVCodec.FF_COMPLIANCE_NORMAL), MIN, MAX, V|D|E, "strict"));
		cls.add_option(new AVOption("unofficial", "allow unofficial extensions", null, OTC, new AVOptionValue(AVCodec.FF_COMPLIANCE_UNOFFICIAL), MIN, MAX, V|D|E, "strict"));
		cls.add_option(new AVOption("experimental", "allow non standardized experimental things", null, OTC, new AVOptionValue(AVCodec.FF_COMPLIANCE_EXPERIMENTAL), MIN, MAX, V|D|E, "strict"));
		cls.add_option(new AVOption("b_qoffset", "qp offset between P and B frames", "b_quant_offset", OTFl, new AVOptionValue(Float.valueOf((float)1.25)), -FLT_MAX, FLT_MAX, V|E));
		cls.add_option(new AVOption("er", "set error detection aggressivity", "error_recognition", OTI, new AVOptionValue(AVCodec.FF_ER_CAREFUL), MIN, MAX, A|V|D, "er"));
		cls.add_option(new AVOption("careful", null, null, OTC, new AVOptionValue(AVCodec.FF_ER_CAREFUL), MIN, MAX, V|D, "er"));
		cls.add_option(new AVOption("compliant", null, null, OTC, new AVOptionValue(AVCodec.FF_ER_COMPLIANT), MIN, MAX, V|D, "er"));
		cls.add_option(new AVOption("aggressive", null, null, OTC, new AVOptionValue(AVCodec.FF_ER_AGGRESSIVE), MIN, MAX, V|D, "er"));
		cls.add_option(new AVOption("very_aggressive", null, null, OTC, new AVOptionValue(AVCodec.FF_ER_VERY_AGGRESSIVE), MIN, MAX, V|D, "er"));
		cls.add_option(new AVOption("has_b_frames", null, "has_b_frames", OTI, new AVOptionValue(DEFAULT), MIN, MAX));
		cls.add_option(new AVOption("block_align", null, "block_align", OTI, new AVOptionValue(DEFAULT), MIN, MAX));
		cls.add_option(new AVOption("parse_only", null, "parse_only", OTI, new AVOptionValue(DEFAULT), MIN, MAX));
		cls.add_option(new AVOption("mpeg_quant", "use MPEG quantizers instead of H.263", "mpeg_quant", OTI, new AVOptionValue(DEFAULT), MIN, MAX, V|E));
		cls.add_option(new AVOption("stats_out", null, "stats_out", OTS, new AVOptionValue(null), CHAR_MIN, CHAR_MAX));
		cls.add_option(new AVOption("stats_in", null, "stats_in", OTS, new AVOptionValue(null), CHAR_MIN, CHAR_MAX));
		cls.add_option(new AVOption("qsquish", "how to keep quantizer between qmin and qmax (0 = clip, 1 = use differentiable function)", "rc_qsquish", OTFl, new AVOptionValue(Float.valueOf(DEFAULT)), 0, 99, V|E));
		cls.add_option(new AVOption("rc_qmod_amp", "experimental quantizer modulation", "rc_qmod_amp", OTFl, new AVOptionValue(Float.valueOf(DEFAULT)), -FLT_MAX, FLT_MAX, V|E));
		cls.add_option(new AVOption("rc_qmod_freq", "experimental quantizer modulation", "rc_qmod_freq", OTI, new AVOptionValue(DEFAULT), MIN, MAX, V|E));
//		cls.add_option(new AVOption("rc_override_count", null, "rc_override_count", OTI, new AVOptionValue(DEFAULT), MIN, MAX));
		cls.add_option(new AVOption("rc_eq", "set rate control equation", "rc_eq", OTS, new AVOptionValue(null), CHAR_MIN, CHAR_MAX, V|E));
		cls.add_option(new AVOption("maxrate", "set max video bitrate tolerance (in bits/s)", "rc_max_rate", OTI, new AVOptionValue(DEFAULT), MIN, MAX, V|E));
		cls.add_option(new AVOption("minrate", "set min video bitrate tolerance (in bits/s)", "rc_min_rate", OTI, new AVOptionValue(DEFAULT), MIN, MAX, V|E));
		cls.add_option(new AVOption("bufsize", "set ratecontrol buffer size (in bits)", "rc_buffer_size", OTI, new AVOptionValue(DEFAULT), MIN, MAX, A|V|E));
		cls.add_option(new AVOption("rc_buf_aggressivity", "currently useless", "rc_buffer_aggressivity", OTFl, new AVOptionValue(Float.valueOf((float)1.0)), -FLT_MAX, FLT_MAX, V|E));
		cls.add_option(new AVOption("i_qfactor", "qp factor between P and I frames", "i_quant_factor", OTFl, new AVOptionValue(Float.valueOf((float)-0.8)), -FLT_MAX, FLT_MAX, V|E));
		cls.add_option(new AVOption("i_qoffset", "qp offset between P and I frames", "i_quant_offset", OTFl, new AVOptionValue(Float.valueOf((float)0.0)), -FLT_MAX, FLT_MAX, V|E));
		cls.add_option(new AVOption("rc_init_cplx", "initial complexity for 1-pass encoding", "rc_initial_cplx", OTFl, new AVOptionValue(Float.valueOf((float)DEFAULT)), -FLT_MAX, FLT_MAX, V|E));
		cls.add_option(new AVOption("dct", "DCT algorithm", "dct_algo", OTI, new AVOptionValue(DEFAULT), 0, MAX, V|E, "dct"));
		cls.add_option(new AVOption("auto", "autoselect a good one (default)", null, OTC, new AVOptionValue(AVCodec.FF_DCT_AUTO), MIN, MAX, V|E, "dct"));
		cls.add_option(new AVOption("fastint", "fast integer", null, OTC, new AVOptionValue(AVCodec.FF_DCT_FASTINT), MIN, MAX, V|E, "dct"));
		cls.add_option(new AVOption("int", "accurate integer", null, OTC, new AVOptionValue(AVCodec.FF_DCT_INT), MIN, MAX, V|E, "dct"));
		cls.add_option(new AVOption("mmx", null, null, OTC, new AVOptionValue(AVCodec.FF_DCT_MMX), MIN, MAX, V|E, "dct"));
		cls.add_option(new AVOption("mlib", null, null, OTC, new AVOptionValue(AVCodec.FF_DCT_MLIB), MIN, MAX, V|E, "dct"));
		cls.add_option(new AVOption("altivec", null, null, OTC, new AVOptionValue(AVCodec.FF_DCT_ALTIVEC), MIN, MAX, V|E, "dct"));
		cls.add_option(new AVOption("faan", "floating point AAN DCT", null, OTC, new AVOptionValue(AVCodec.FF_DCT_FAAN), MIN, MAX, V|E, "dct"));
		cls.add_option(new AVOption("lumi_mask", "compresses bright areas stronger than medium ones", "lumi_masking", OTFl, new AVOptionValue(Float.valueOf((float)0)), -FLT_MAX, FLT_MAX, V|E));
		cls.add_option(new AVOption("tcplx_mask", "temporal complexity masking", "temporal_cplx_masking", OTFl, new AVOptionValue(Float.valueOf((float)0)), -FLT_MAX, FLT_MAX, V|E));
		cls.add_option(new AVOption("scplx_mask", "spatial complexity masking", "spatial_cplx_masking", OTFl, new AVOptionValue(Float.valueOf((float)0)), -FLT_MAX, FLT_MAX, V|E));
		cls.add_option(new AVOption("p_mask", "inter masking", "p_masking", OTFl, new AVOptionValue(Float.valueOf((float)0)), -FLT_MAX, FLT_MAX, V|E));
		cls.add_option(new AVOption("dark_mask", "compresses dark areas stronger than medium ones", "dark_masking", OTFl, new AVOptionValue(Float.valueOf((float)0)), -FLT_MAX, FLT_MAX, V|E));
		cls.add_option(new AVOption("idct", "select IDCT implementation", "idct_algo", OTI, new AVOptionValue(DEFAULT), 0, MAX, V|E|D, "idct"));
		cls.add_option(new AVOption("auto", null, null, OTC, new AVOptionValue(AVCodec.FF_IDCT_AUTO), MIN, MAX, V|E|D, "idct"));
		cls.add_option(new AVOption("int", null, null, OTC, new AVOptionValue(AVCodec.FF_IDCT_INT), MIN, MAX, V|E|D, "idct"));
		cls.add_option(new AVOption("simple", null, null, OTC, new AVOptionValue(AVCodec.FF_IDCT_SIMPLE), MIN, MAX, V|E|D, "idct"));
		cls.add_option(new AVOption("simplemmx", null, null, OTC, new AVOptionValue(AVCodec.FF_IDCT_SIMPLEMMX), MIN, MAX, V|E|D, "idct"));
		cls.add_option(new AVOption("libmpeg2mmx", null, null, OTC, new AVOptionValue(AVCodec.FF_IDCT_LIBMPEG2MMX), MIN, MAX, V|E|D, "idct"));
		cls.add_option(new AVOption("ps2", null, null, OTC, new AVOptionValue(AVCodec.FF_IDCT_PS2), MIN, MAX, V|E|D, "idct"));
		cls.add_option(new AVOption("mlib", null, null, OTC, new AVOptionValue(AVCodec.FF_IDCT_MLIB), MIN, MAX, V|E|D, "idct"));
		cls.add_option(new AVOption("arm", null, null, OTC, new AVOptionValue(AVCodec.FF_IDCT_ARM), MIN, MAX, V|E|D, "idct"));
		cls.add_option(new AVOption("altivec", null, null, OTC, new AVOptionValue(AVCodec.FF_IDCT_ALTIVEC), MIN, MAX, V|E|D, "idct"));
		cls.add_option(new AVOption("sh4", null, null, OTC, new AVOptionValue(AVCodec.FF_IDCT_SH4), MIN, MAX, V|E|D, "idct"));
		cls.add_option(new AVOption("simplearm", null, null, OTC, new AVOptionValue(AVCodec.FF_IDCT_SIMPLEARM), MIN, MAX, V|E|D, "idct"));
		cls.add_option(new AVOption("simplearmv5te", null, null, OTC, new AVOptionValue(AVCodec.FF_IDCT_SIMPLEARMV5TE), MIN, MAX, V|E|D, "idct"));
		cls.add_option(new AVOption("simplearmv6", null, null, OTC, new AVOptionValue(AVCodec.FF_IDCT_SIMPLEARMV6), MIN, MAX, V|E|D, "idct"));
		cls.add_option(new AVOption("simpleneon", null, null, OTC, new AVOptionValue(AVCodec.FF_IDCT_SIMPLENEON), MIN, MAX, V|E|D, "idct"));
		cls.add_option(new AVOption("simplealpha", null, null, OTC, new AVOptionValue(AVCodec.FF_IDCT_SIMPLEALPHA), MIN, MAX, V|E|D, "idct"));
		cls.add_option(new AVOption("h264", null, null, OTC, new AVOptionValue(AVCodec.FF_IDCT_H264), MIN, MAX, V|E|D, "idct"));
		cls.add_option(new AVOption("vp3", null, null, OTC, new AVOptionValue(AVCodec.FF_IDCT_VP3), MIN, MAX, V|E|D, "idct"));
		cls.add_option(new AVOption("ipp", null, null, OTC, new AVOptionValue(AVCodec.FF_IDCT_IPP), MIN, MAX, V|E|D, "idct"));
		cls.add_option(new AVOption("xvidmmx", null, null, OTC, new AVOptionValue(AVCodec.FF_IDCT_XVIDMMX), MIN, MAX, V|E|D, "idct"));
		cls.add_option(new AVOption("faani", "floating point AAN IDCT", null, OTC, new AVOptionValue(AVCodec.FF_IDCT_FAAN), MIN, MAX, V|D|E, "idct"));
		cls.add_option(new AVOption("slice_count", null, "slice_count", OTI, new AVOptionValue(DEFAULT), MIN, MAX));
		cls.add_option(new AVOption("ec", "set error concealment strategy", "error_concealment", OTF, new AVOptionValue(3), MIN, MAX, V|D, "ec"));
		cls.add_option(new AVOption("guess_mvs", "iterative motion vector (MV) search (slow)", null, OTC, new AVOptionValue(AVCodec.FF_EC_GUESS_MVS), MIN, MAX, V|D, "ec"));
		cls.add_option(new AVOption("deblock", "use strong deblock filter for damaged MBs", null, OTC, new AVOptionValue(AVCodec.FF_EC_DEBLOCK), MIN, MAX, V|D, "ec"));
		cls.add_option(new AVOption("bits_per_coded_sample", null, "bits_per_coded_sample", OTI, new AVOptionValue(DEFAULT), MIN, MAX));
		cls.add_option(new AVOption("pred", "prediction method", "prediction_method", OTI, new AVOptionValue(DEFAULT), MIN, MAX, V|E, "pred"));
		cls.add_option(new AVOption("left", null, null, OTC, new AVOptionValue(AVCodec.FF_PRED_LEFT), MIN, MAX, V|E, "pred"));
		cls.add_option(new AVOption("plane", null, null, OTC, new AVOptionValue(AVCodec.FF_PRED_PLANE), MIN, MAX, V|E, "pred"));
		cls.add_option(new AVOption("median", null, null, OTC, new AVOptionValue(AVCodec.FF_PRED_MEDIAN), MIN, MAX, V|E, "pred"));
		cls.add_option(new AVOption("aspect", "sample aspect ratio", "sample_aspect_ratio", OTR, new AVOptionValue(Double.valueOf(0)), 0, 10, V|E));
		cls.add_option(new AVOption("debug", "print specific debug info", "debug", OTF, new AVOptionValue(DEFAULT), 0, MAX, V|A|S|E|D, "debug"));
		cls.add_option(new AVOption("pict", "picture info", null, OTC, new AVOptionValue(AVCodec.FF_DEBUG_PICT_INFO), MIN, MAX, V|D, "debug"));
		cls.add_option(new AVOption("rc", "rate control", null, OTC, new AVOptionValue(AVCodec.FF_DEBUG_RC), MIN, MAX, V|E, "debug"));
		cls.add_option(new AVOption("bitstream", null, null, OTC, new AVOptionValue(AVCodec.FF_DEBUG_BITSTREAM), MIN, MAX, V|D, "debug"));
		cls.add_option(new AVOption("mb_type", "macroblock (MB) type", null, OTC, new AVOptionValue(AVCodec.FF_DEBUG_MB_TYPE), MIN, MAX, V|D, "debug"));
		cls.add_option(new AVOption("qp", "per-block quantization parameter (QP)", null, OTC, new AVOptionValue(AVCodec.FF_DEBUG_QP), MIN, MAX, V|D, "debug"));
		cls.add_option(new AVOption("mv", "motion vector", null, OTC, new AVOptionValue(AVCodec.FF_DEBUG_MV), MIN, MAX, V|D, "debug"));
		cls.add_option(new AVOption("dct_coeff", null, null, OTC, new AVOptionValue(AVCodec.FF_DEBUG_DCT_COEFF), MIN, MAX, V|D, "debug"));
		cls.add_option(new AVOption("skip", null, null, OTC, new AVOptionValue(AVCodec.FF_DEBUG_SKIP), MIN, MAX, V|D, "debug"));
		cls.add_option(new AVOption("startcode", null, null, OTC, new AVOptionValue(AVCodec.FF_DEBUG_STARTCODE), MIN, MAX, V|D, "debug"));
		cls.add_option(new AVOption("pts", null, null, OTC, new AVOptionValue(AVCodec.FF_DEBUG_PTS), MIN, MAX, V|D, "debug"));
		cls.add_option(new AVOption("er", "error recognition", null, OTC, new AVOptionValue(AVCodec.FF_DEBUG_ER), MIN, MAX, V|D, "debug"));
		cls.add_option(new AVOption("mmco", "memory management control operations (H.264)", null, OTC, new AVOptionValue(AVCodec.FF_DEBUG_MMCO), MIN, MAX, V|D, "debug"));
		cls.add_option(new AVOption("bugs", null, null, OTC, new AVOptionValue(AVCodec.FF_DEBUG_BUGS), MIN, MAX, V|D, "debug"));
		cls.add_option(new AVOption("vis_qp", "visualize quantization parameter (QP) lower QP are tinted greener", null, OTC, new AVOptionValue(AVCodec.FF_DEBUG_VIS_QP), MIN, MAX, V|D, "debug"));
		cls.add_option(new AVOption("vis_mb_type", "visualize block types", null, OTC, new AVOptionValue(AVCodec.FF_DEBUG_VIS_MB_TYPE), MIN, MAX, V|D, "debug"));
		cls.add_option(new AVOption("buffers", "picture buffer allocations", null, OTC, new AVOptionValue(AVCodec.FF_DEBUG_BUFFERS), MIN, MAX, V|D, "debug"));
		cls.add_option(new AVOption("thread_ops", "threading operations", null, OTC, new AVOptionValue(AVCodec.FF_DEBUG_THREADS), MIN, MAX, V|D, "debug"));
		cls.add_option(new AVOption("vismv", "visualize motion vectors (MVs)", "debug_mv", OTI, new AVOptionValue(DEFAULT), 0, MAX, V|D, "debug_mv"));
		cls.add_option(new AVOption("pf", "forward predicted MVs of P-frames", null, OTC, new AVOptionValue(AVCodec.FF_DEBUG_VIS_MV_P_FOR), MIN, MAX, V|D, "debug_mv"));
		cls.add_option(new AVOption("bf", "forward predicted MVs of B-frames", null, OTC, new AVOptionValue(AVCodec.FF_DEBUG_VIS_MV_B_FOR), MIN, MAX, V|D, "debug_mv"));
		cls.add_option(new AVOption("bb", "backward predicted MVs of B-frames", null, OTC, new AVOptionValue(AVCodec.FF_DEBUG_VIS_MV_B_BACK), MIN, MAX, V|D, "debug_mv"));
		cls.add_option(new AVOption("cmp", "full pel me compare function", "me_cmp", OTI, new AVOptionValue(DEFAULT), MIN, MAX, V|E, "cmp_func"));
		cls.add_option(new AVOption("subcmp", "sub pel me compare function", "me_sub_cmp", OTI, new AVOptionValue(DEFAULT), MIN, MAX, V|E, "cmp_func"));
		cls.add_option(new AVOption("mbcmp", "macroblock compare function", "mb_cmp", OTI, new AVOptionValue(DEFAULT), MIN, MAX, V|E, "cmp_func"));
		cls.add_option(new AVOption("ildctcmp", "interlaced dct compare function", "ildct_cmp", OTI, new AVOptionValue(AVCodec.FF_CMP_VSAD), MIN, MAX, V|E, "cmp_func"));
		cls.add_option(new AVOption("dia_size", "diamond type & size for motion estimation", "dia_size", OTI, new AVOptionValue(DEFAULT), MIN, MAX, V|E));
		cls.add_option(new AVOption("last_pred", "amount of motion predictors from the previous frame", "last_predictor_count", OTI, new AVOptionValue(DEFAULT), MIN, MAX, V|E));
		cls.add_option(new AVOption("preme", "pre motion estimation", "pre_me", OTI, new AVOptionValue(DEFAULT), MIN, MAX, V|E));
		cls.add_option(new AVOption("precmp", "pre motion estimation compare function", "me_pre_cmp", OTI, new AVOptionValue(DEFAULT), MIN, MAX, V|E, "cmp_func"));
		cls.add_option(new AVOption("sad", "sum of absolute differences, fast (default)", null, OTC, new AVOptionValue(AVCodec.FF_CMP_SAD), MIN, MAX, V|E, "cmp_func"));
		cls.add_option(new AVOption("sse", "sum of squared errors", null, OTC, new AVOptionValue(AVCodec.FF_CMP_SSE), MIN, MAX, V|E, "cmp_func"));
		cls.add_option(new AVOption("satd", "sum of absolute Hadamard transformed differences", null, OTC, new AVOptionValue(AVCodec.FF_CMP_SATD), MIN, MAX, V|E, "cmp_func"));
		cls.add_option(new AVOption("dct", "sum of absolute DCT transformed differences", null, OTC, new AVOptionValue(AVCodec.FF_CMP_DCT), MIN, MAX, V|E, "cmp_func"));
		cls.add_option(new AVOption("psnr", "sum of squared quantization errors (avoid, low quality)", null, OTC, new AVOptionValue(AVCodec.FF_CMP_PSNR), MIN, MAX, V|E, "cmp_func"));
		cls.add_option(new AVOption("bit", "number of bits needed for the block", null, OTC, new AVOptionValue(AVCodec.FF_CMP_BIT), MIN, MAX, V|E, "cmp_func"));
		cls.add_option(new AVOption("rd", "rate distortion optimal, slow", null, OTC, new AVOptionValue(AVCodec.FF_CMP_RD), MIN, MAX, V|E, "cmp_func"));
		cls.add_option(new AVOption("zero", "0", null, OTC, new AVOptionValue(AVCodec.FF_CMP_ZERO), MIN, MAX, V|E, "cmp_func"));
		cls.add_option(new AVOption("vsad", "sum of absolute vertical differences", null, OTC, new AVOptionValue(AVCodec.FF_CMP_VSAD), MIN, MAX, V|E, "cmp_func"));
		cls.add_option(new AVOption("vsse", "sum of squared vertical differences", null, OTC, new AVOptionValue(AVCodec.FF_CMP_VSSE), MIN, MAX, V|E, "cmp_func"));
		cls.add_option(new AVOption("nsse", "noise preserving sum of squared differences", null, OTC, new AVOptionValue(AVCodec.FF_CMP_NSSE), MIN, MAX, V|E, "cmp_func"));
		cls.add_option(new AVOption("dctmax", null, null, OTC, new AVOptionValue(AVCodec.FF_CMP_DCTMAX), MIN, MAX, V|E, "cmp_func"));
		cls.add_option(new AVOption("chroma", null, null, OTC, new AVOptionValue(AVCodec.FF_CMP_CHROMA), MIN, MAX, V|E, "cmp_func"));
		cls.add_option(new AVOption("pre_dia_size", "diamond type & size for motion estimation pre-pass", "pre_dia_size", OTI, new AVOptionValue(DEFAULT), MIN, MAX, V|E));
		cls.add_option(new AVOption("subq", "sub pel motion estimation quality", "me_subpel_quality", OTI, new AVOptionValue(8), MIN, MAX, V|E));
		cls.add_option(new AVOption("dtg_active_format", null, "dtg_active_format", OTI, new AVOptionValue(DEFAULT), MIN, MAX));
		cls.add_option(new AVOption("me_range", "limit motion vectors range (1023 for DivX player)", "me_range", OTI, new AVOptionValue(DEFAULT), MIN, MAX, V|E));
		cls.add_option(new AVOption("ibias", "intra quant bias", "intra_quant_bias", OTI, new AVOptionValue(AVCodec.FF_DEFAULT_QUANT_BIAS), MIN, MAX, V|E));
		cls.add_option(new AVOption("pbias", "inter quant bias", "inter_quant_bias", OTI, new AVOptionValue(AVCodec.FF_DEFAULT_QUANT_BIAS), MIN, MAX, V|E));
		cls.add_option(new AVOption("color_table_id", null, "color_table_id", OTI, new AVOptionValue(DEFAULT), MIN, MAX));
		cls.add_option(new AVOption("internal_buffer_count", null, "internal_buffer_count", OTI, new AVOptionValue(DEFAULT), MIN, MAX));
		cls.add_option(new AVOption("global_quality", null, "global_quality", OTI, new AVOptionValue(DEFAULT), MIN, MAX));
		cls.add_option(new AVOption("coder", null, "coder_type", OTI, new AVOptionValue(DEFAULT), MIN, MAX, V|E, "coder"));
		cls.add_option(new AVOption("vlc", "variable length coder / huffman coder", null, OTC, new AVOptionValue(AVCodec.FF_CODER_TYPE_VLC), MIN, MAX, V|E, "coder"));
		cls.add_option(new AVOption("ac", "arithmetic coder", null, OTC, new AVOptionValue(AVCodec.FF_CODER_TYPE_AC), MIN, MAX, V|E, "coder"));
		cls.add_option(new AVOption("raw", "raw (no encoding)", null, OTC, new AVOptionValue(AVCodec.FF_CODER_TYPE_RAW), MIN, MAX, V|E, "coder"));
		cls.add_option(new AVOption("rle", "run-length coder", null, OTC, new AVOptionValue(AVCodec.FF_CODER_TYPE_RLE), MIN, MAX, V|E, "coder"));
		cls.add_option(new AVOption("deflate", "deflate-based coder", null, OTC, new AVOptionValue(AVCodec.FF_CODER_TYPE_DEFLATE), MIN, MAX, V|E, "coder"));
		cls.add_option(new AVOption("context", "context model", "context_model", OTI, new AVOptionValue(DEFAULT), MIN, MAX, V|E));
		cls.add_option(new AVOption("slice_flags", null, "slice_flags", OTI, new AVOptionValue(DEFAULT), MIN, MAX));
		cls.add_option(new AVOption("xvmc_acceleration", null, "xvmc_acceleration", OTI, new AVOptionValue(DEFAULT), MIN, MAX));
		cls.add_option(new AVOption("mbd", "macroblock decision algorithm (high quality mode)", "mb_decision", OTI, new AVOptionValue(DEFAULT), MIN, MAX, V|E, "mbd"));
		cls.add_option(new AVOption("simple", "use mbcmp (default)", 0, OTC, new AVOptionValue(AVCodec.FF_MB_DECISION_SIMPLE), MIN, MAX, V|E, "mbd"));
		cls.add_option(new AVOption("bits", "use fewest bits", 0, OTC, new AVOptionValue(AVCodec.FF_MB_DECISION_BITS), MIN, MAX, V|E, "mbd"));
		cls.add_option(new AVOption("rd", "use best rate distortion", 0, OTC, new AVOptionValue(AVCodec.FF_MB_DECISION_RD), MIN, MAX, V|E, "mbd"));
		cls.add_option(new AVOption("stream_codec_tag", null, "stream_codec_tag", OTI, new AVOptionValue(DEFAULT), MIN, MAX));
		cls.add_option(new AVOption("sc_threshold", "scene change threshold", "scenechange_threshold", OTI, new AVOptionValue(DEFAULT), MIN, MAX, V|E));
		cls.add_option(new AVOption("lmin", "min lagrange factor (VBR)", "lmin", OTI, new AVOptionValue( 2*AVUtil.FF_QP2LAMBDA), 0, MAX, V|E));
		cls.add_option(new AVOption("lmax", "max lagrange factor (VBR)", "lmax", OTI, new AVOptionValue(31*AVUtil.FF_QP2LAMBDA), 0, MAX, V|E));
		cls.add_option(new AVOption("nr", "noise reduction", "noise_reduction", OTI, new AVOptionValue(DEFAULT), MIN, MAX, V|E));
		cls.add_option(new AVOption("rc_init_occupancy", "number of bits which should be loaded into the rc buffer before decoding starts", "rc_initial_buffer_occupancy", OTI, new AVOptionValue(DEFAULT), MIN, MAX, V|E));
		cls.add_option(new AVOption("inter_threshold", null, "inter_threshold", OTI, new AVOptionValue(DEFAULT), MIN, MAX, V|E));
		cls.add_option(new AVOption("flags2", null, "flags2", OTF, new AVOptionValue(AVCodec.CODEC_FLAG2_FASTPSKIP|AVCodec.CODEC_FLAG2_BIT_RESERVOIR|AVCodec.CODEC_FLAG2_PSY|AVCodec.CODEC_FLAG2_MBTREE), 0, UINT_MAX, V|A|E|D, "flags2"));
		cls.add_option(new AVOption("error", null, "error_rate", OTI, new AVOptionValue(DEFAULT), MIN, MAX, V|E));
		cls.add_option(new AVOption("qns", "quantizer noise shaping", "quantizer_noise_shaping", OTI, new AVOptionValue(DEFAULT), MIN, MAX, V|E));
		cls.add_option(new AVOption("threads", null, "thread_count", OTI, new AVOptionValue(1), MIN, MAX, V|E|D));
		cls.add_option(new AVOption("me_threshold", "motion estimaton threshold", "me_threshold", OTI, new AVOptionValue(DEFAULT), MIN, MAX));
		cls.add_option(new AVOption("mb_threshold", "macroblock threshold", "mb_threshold", OTI, new AVOptionValue(DEFAULT), MIN, MAX, V|E));
		cls.add_option(new AVOption("dc", "intra_dc_precision", "intra_dc_precision", OTI, new AVOptionValue(0), MIN, MAX, V|E));
		cls.add_option(new AVOption("nssew", "nsse weight", "nsse_weight", OTI, new AVOptionValue(8), MIN, MAX, V|E));
		cls.add_option(new AVOption("skip_top", "number of macroblock rows at the top which are skipped", "skip_top", OTI, new AVOptionValue(DEFAULT), MIN, MAX, V|D));
		cls.add_option(new AVOption("skip_bottom", "number of macroblock rows at the bottom which are skipped", "skip_bottom", OTI, new AVOptionValue(DEFAULT), MIN, MAX, V|D));
		cls.add_option(new AVOption("profile", null, "profile", OTI, new AVOptionValue(AVCodec.FF_PROFILE_UNKNOWN), MIN, MAX, V|A|E, "profile"));
		cls.add_option(new AVOption("unknown", null, 0, OTC, new AVOptionValue(AVCodec.FF_PROFILE_UNKNOWN), MIN, MAX, V|A|E, "profile"));
		cls.add_option(new AVOption("aac_main", null, 0, OTC, new AVOptionValue(AVCodec.FF_PROFILE_AAC_MAIN), MIN, MAX, A|E, "profile"));
		cls.add_option(new AVOption("aac_low", null, 0, OTC, new AVOptionValue(AVCodec.FF_PROFILE_AAC_LOW), MIN, MAX, A|E, "profile"));
		cls.add_option(new AVOption("aac_ssr", null, 0, OTC, new AVOptionValue(AVCodec.FF_PROFILE_AAC_SSR), MIN, MAX, A|E, "profile"));
		cls.add_option(new AVOption("aac_ltp", null, 0, OTC, new AVOptionValue(AVCodec.FF_PROFILE_AAC_LTP), MIN, MAX, A|E, "profile"));
		cls.add_option(new AVOption("dts", null, 0, OTC, new AVOptionValue(AVCodec.FF_PROFILE_DTS), MIN, MAX, A|E, "profile"));
		cls.add_option(new AVOption("dts_es", null, 0, OTC, new AVOptionValue(AVCodec.FF_PROFILE_DTS_ES), MIN, MAX, A|E, "profile"));
		cls.add_option(new AVOption("dts_96_24", null, 0, OTC, new AVOptionValue(AVCodec.FF_PROFILE_DTS_96_24), MIN, MAX, A|E, "profile"));
		cls.add_option(new AVOption("dts_hd_hra", null, 0, OTC, new AVOptionValue(AVCodec.FF_PROFILE_DTS_HD_HRA), MIN, MAX, A|E, "profile"));
		cls.add_option(new AVOption("dts_hd_ma", null, 0, OTC, new AVOptionValue(AVCodec.FF_PROFILE_DTS_HD_MA), MIN, MAX, A|E, "profile"));
		cls.add_option(new AVOption("level", null, "level", OTI, new AVOptionValue(AVCodec.FF_LEVEL_UNKNOWN), MIN, MAX, V|A|E, "level"));
		cls.add_option(new AVOption("unknown", null, 0, OTC, new AVOptionValue(AVCodec.FF_LEVEL_UNKNOWN), MIN, MAX, V|A|E, "level"));
		cls.add_option(new AVOption("lowres", "decode at 1= 1/2, 2=1/4, 3=1/8 resolutions", "lowres", OTI, new AVOptionValue(0), 0, MAX, V|A|D));
		cls.add_option(new AVOption("skip_threshold", "frame skip threshold", "frame_skip_threshold", OTI, new AVOptionValue(DEFAULT), MIN, MAX, V|E));
		cls.add_option(new AVOption("skip_factor", "frame skip factor", "frame_skip_factor", OTI, new AVOptionValue(DEFAULT), MIN, MAX, V|E));
		cls.add_option(new AVOption("skip_exp", "frame skip exponent", "frame_skip_exp", OTI, new AVOptionValue(DEFAULT), MIN, MAX, V|E));
		cls.add_option(new AVOption("skipcmp", "frame skip compare function", "frame_skip_cmp", OTI, new AVOptionValue(AVCodec.FF_CMP_DCTMAX), MIN, MAX, V|E, "cmp_func"));
		cls.add_option(new AVOption("border_mask", "increases the quantizer for macroblocks close to borders", "border_masking", OTFl, new AVOptionValue(Float.valueOf((float)DEFAULT)), -FLT_MAX, FLT_MAX, V|E));
		cls.add_option(new AVOption("mblmin", "min macroblock lagrange factor (VBR)", "mb_lmin", OTI, new AVOptionValue(AVUtil.FF_QP2LAMBDA * 2), 1, AVUtil.FF_LAMBDA_MAX, V|E));
		cls.add_option(new AVOption("mblmax", "max macroblock lagrange factor (VBR)", "mb_lmax", OTI, new AVOptionValue(AVUtil.FF_QP2LAMBDA * 31), 1, AVUtil.FF_LAMBDA_MAX, V|E));
		cls.add_option(new AVOption("mepc", "motion estimation bitrate penalty compensation (1.0 = 256)", "me_penalty_compensation", OTI, new AVOptionValue(256), MIN, MAX, V|E));
		cls.add_option(new AVOption("skip_loop_filter", null, "skip_loop_filter", OTE, new AVOptionValue(AVDiscard.AVDISCARD_DEFAULT), MIN, MAX, V|D, "avdiscard"));
		cls.add_option(new AVOption("skip_idct"       , null, "skip_idct"       , OTE, new AVOptionValue(AVDiscard.AVDISCARD_DEFAULT), MIN, MAX, V|D, "avdiscard"));
		cls.add_option(new AVOption("skip_frame"      , null, "skip_frame"      , OTE, new AVOptionValue(AVDiscard.AVDISCARD_DEFAULT), MIN, MAX, V|D, "avdiscard"));
		cls.add_option(new AVOption("none"            , null, 0, OTC, new AVOptionValue(AVDiscard.AVDISCARD_NONE), MIN, MAX, V|D, "avdiscard"));
		cls.add_option(new AVOption("default"         , null, 0, OTC, new AVOptionValue(AVDiscard.AVDISCARD_DEFAULT), MIN, MAX, V|D, "avdiscard"));
		cls.add_option(new AVOption("noref"           , null, 0, OTC, new AVOptionValue(AVDiscard.AVDISCARD_NONREF), MIN, MAX, V|D, "avdiscard"));
		cls.add_option(new AVOption("bidir"           , null, 0, OTC, new AVOptionValue(AVDiscard.AVDISCARD_BIDIR), MIN, MAX, V|D, "avdiscard"));
		cls.add_option(new AVOption("nokey"           , null, 0, OTC, new AVOptionValue(AVDiscard.AVDISCARD_NONKEY), MIN, MAX, V|D, "avdiscard"));
		cls.add_option(new AVOption("all"             , null, 0, OTC, new AVOptionValue(AVDiscard.AVDISCARD_ALL), MIN, MAX, V|D, "avdiscard"));
		cls.add_option(new AVOption("bidir_refine", "refine the two motion vectors used in bidirectional macroblocks", "bidir_refine", OTI, new AVOptionValue(1), 0, 4, V|E));
		cls.add_option(new AVOption("brd_scale", "downscales frames for dynamic B-frame decision", "brd_scale", OTI, new AVOptionValue(DEFAULT), 0, 10, V|E));
		cls.add_option(new AVOption("crf", "enables constant quality mode, and selects the quality (x264/VP8)", "crf", OTFl, new AVOptionValue(Float.valueOf((float)DEFAULT)), 0, 63, V|E));
		cls.add_option(new AVOption("cqp", "constant quantization parameter rate control method", "cqp", OTI, new AVOptionValue(-1), MIN, MAX, V|E));
		cls.add_option(new AVOption("keyint_min", "minimum interval between IDR-frames", "keyint_min", OTI, new AVOptionValue(25), MIN, MAX, V|E));
		cls.add_option(new AVOption("refs", "reference frames to consider for motion compensation", "refs", OTI, new AVOptionValue(1), MIN, MAX, V|E));
		cls.add_option(new AVOption("chromaoffset", "chroma qp offset from luma", "chromaoffset", OTI, new AVOptionValue(DEFAULT), MIN, MAX, V|E));
		cls.add_option(new AVOption("bframebias", "influences how often B-frames are used", "bframebias", OTI, new AVOptionValue(DEFAULT), MIN, MAX, V|E));
		cls.add_option(new AVOption("trellis", "rate-distortion optimal quantization", "trellis", OTI, new AVOptionValue(DEFAULT), MIN, MAX, V|A|E));
		cls.add_option(new AVOption("directpred", "direct mv prediction mode - 0 (none), 1 (spatial), 2 (temporal), 3 (auto)", "directpred", OTI, new AVOptionValue(2), MIN, MAX, V|E));
		cls.add_option(new AVOption("bpyramid", "allows B-frames to be used as references for predicting", 0, OTC, new AVOptionValue(AVCodec.CODEC_FLAG2_BPYRAMID), MIN, MAX, V|E, "flags2"));
		cls.add_option(new AVOption("wpred", "weighted biprediction for b-frames (H.264)", 0, OTC, new AVOptionValue(AVCodec.CODEC_FLAG2_WPRED), MIN, MAX, V|E, "flags2"));
		cls.add_option(new AVOption("mixed_refs", "one reference per partition, as opposed to one reference per macroblock", 0, OTC, new AVOptionValue(AVCodec.CODEC_FLAG2_MIXED_REFS), MIN, MAX, V|E, "flags2"));
		cls.add_option(new AVOption("dct8x8", "high profile 8x8 transform (H.264)", 0, OTC, new AVOptionValue(AVCodec.CODEC_FLAG2_8X8DCT), MIN, MAX, V|E, "flags2"));
		cls.add_option(new AVOption("fastpskip", "fast pskip (H.264)", 0, OTC, new AVOptionValue(AVCodec.CODEC_FLAG2_FASTPSKIP), MIN, MAX, V|E, "flags2"));
		cls.add_option(new AVOption("aud", "access unit delimiters (H.264)", 0, OTC, new AVOptionValue(AVCodec.CODEC_FLAG2_AUD), MIN, MAX, V|E, "flags2"));
		cls.add_option(new AVOption("skiprd", "RD optimal MB level residual skipping", 0, OTC, new AVOptionValue(AVCodec.CODEC_FLAG2_SKIP_RD), MIN, MAX, V|E, "flags2"));
		cls.add_option(new AVOption("complexityblur", "reduce fluctuations in qp (before curve compression)", "complexityblur", OTFl, new AVOptionValue(Float.valueOf((float)20.0)), FLT_MIN, FLT_MAX, V|E));
		cls.add_option(new AVOption("deblockalpha", "in-loop deblocking filter alphac0 parameter", "deblockalpha", OTI, new AVOptionValue(DEFAULT), -6, 6, V|E));
		cls.add_option(new AVOption("deblockbeta", "in-loop deblocking filter beta parameter", "deblockbeta", OTI, new AVOptionValue(DEFAULT), -6, 6, V|E));
		cls.add_option(new AVOption("partitions", "macroblock subpartition sizes to consider", "partitions", OTF, new AVOptionValue(DEFAULT), MIN, MAX, V|E, "partitions"));
		cls.add_option(new AVOption("parti4x4", null, 0, OTC, new AVOptionValue(AVCodec.X264_PART_I4X4), MIN, MAX, V|E, "partitions"));
		cls.add_option(new AVOption("parti8x8", null, 0, OTC, new AVOptionValue(AVCodec.X264_PART_I8X8), MIN, MAX, V|E, "partitions"));
		cls.add_option(new AVOption("partp4x4", null, 0, OTC, new AVOptionValue(AVCodec.X264_PART_P4X4), MIN, MAX, V|E, "partitions"));
		cls.add_option(new AVOption("partp8x8", null, 0, OTC, new AVOptionValue(AVCodec.X264_PART_P8X8), MIN, MAX, V|E, "partitions"));
		cls.add_option(new AVOption("partb8x8", null, 0, OTC, new AVOptionValue(AVCodec.X264_PART_B8X8), MIN, MAX, V|E, "partitions"));
		cls.add_option(new AVOption("sc_factor", "multiplied by qscale for each frame and added to scene_change_score", "scenechange_factor", OTI, new AVOptionValue(6), 0, MAX, V|E));
		cls.add_option(new AVOption("mv0_threshold", null, "mv0_threshold", OTI, new AVOptionValue(256), 0, MAX, V|E));
		cls.add_option(new AVOption("ivlc", "intra vlc table", 0, OTC, new AVOptionValue(AVCodec.CODEC_FLAG2_INTRA_VLC), MIN, MAX, V|E, "flags2"));
		cls.add_option(new AVOption("b_sensitivity", "adjusts sensitivity of b_frame_strategy 1", "b_sensitivity", OTI, new AVOptionValue(40), 1, MAX, V|E));
		cls.add_option(new AVOption("compression_level", null, "compression_level", OTI, new AVOptionValue(AVCodec.FF_COMPRESSION_DEFAULT), MIN, MAX, V|A|E));
		cls.add_option(new AVOption("min_prediction_order", null, "min_prediction_order", OTI, new AVOptionValue(-1), MIN, MAX, A|E));
		cls.add_option(new AVOption("max_prediction_order", null, "max_prediction_order", OTI, new AVOptionValue(-1), MIN, MAX, A|E));

		cls.add_option(new AVOption("timecode_frame_start", "GOP timecode frame start number, in non drop frame format", "timecode_frame_start", OTI64, new AVOptionValue(Long.valueOf(0)), 0, INT64_MAX, V|E));
		cls.add_option(new AVOption("drop_frame_timecode", null, 0, OTC, new AVOptionValue(AVCodec.CODEC_FLAG2_DROP_FRAME_TIMECODE), MIN, MAX, V|E, "flags2"));
		cls.add_option(new AVOption("non_linear_q", "use non linear quantizer", 0, OTC, new AVOptionValue(AVCodec.CODEC_FLAG2_NON_LINEAR_QUANT), MIN, MAX, V|E, "flags2"));

		cls.add_option(new AVOption("drc_scale", "percentage of dynamic range compression to apply", "drc_scale", OTFl, new AVOptionValue(Float.valueOf((float)1.0)), 0.0, 1.0, A|D));
		cls.add_option(new AVOption("reservoir", "use bit reservoir", 0, OTC, new AVOptionValue(AVCodec.CODEC_FLAG2_BIT_RESERVOIR), MIN, MAX, A|E, "flags2"));
		cls.add_option(new AVOption("mbtree", "use macroblock tree ratecontrol (x264 only)", 0, OTC, new AVOptionValue(AVCodec.CODEC_FLAG2_MBTREE), MIN, MAX, V|E, "flags2"));
		cls.add_option(new AVOption("bits_per_raw_sample", null, "bits_per_raw_sample", OTI, new AVOptionValue(DEFAULT), MIN, MAX));
		cls.add_option(new AVOption("channel_layout", null, "channel_layout", OTI64, new AVOptionValue(Long.valueOf(DEFAULT)), 0, INT64_MAX, A|E|D, "channel_layout"));
		cls.add_option(new AVOption("request_channel_layout", null, "request_channel_layout", OTI64, new AVOptionValue(Long.valueOf(DEFAULT)), 0, INT64_MAX, A|D, "request_channel_layout"));
		cls.add_option(new AVOption("rc_max_vbv_use", null, "rc_max_available_vbv_use", OTFl, new AVOptionValue(Float.valueOf((float)1.0/3)), 0.0, FLT_MAX, V|E));
		cls.add_option(new AVOption("rc_min_vbv_use", null, "rc_min_vbv_overflow_use",  OTFl, new AVOptionValue(Float.valueOf((float)3)),     0.0, FLT_MAX, V|E));
		cls.add_option(new AVOption("ticks_per_frame", null, "ticks_per_frame", OTI, new AVOptionValue(1), 1, MAX, A|V|E|D));
		cls.add_option(new AVOption("color_primaries", null, "color_primaries", OTE, new AVOptionValue(AVColorPrimaries.AVCOL_PRI_UNSPECIFIED), 1, AVColorPrimaries.AVCOL_PRI_NB.ordinal()-1, V|E|D));
		cls.add_option(new AVOption("color_trc", null, "color_trc", OTE, new AVOptionValue(AVColorTransferCharacteristic.AVCOL_TRC_UNSPECIFIED), 1, AVColorTransferCharacteristic.AVCOL_TRC_NB.ordinal()-1, V|E|D));
		cls.add_option(new AVOption("colorspace", null, "colorspace", OTE, new AVOptionValue(AVColorSpace.AVCOL_SPC_UNSPECIFIED), 1, AVColorSpace.AVCOL_SPC_NB.ordinal()-1, V|E|D));
		cls.add_option(new AVOption("color_range", null, "color_range", OTE, new AVOptionValue(AVColorRange.AVCOL_RANGE_UNSPECIFIED), 0, AVColorRange.AVCOL_RANGE_NB.ordinal()-1, V|E|D));
		cls.add_option(new AVOption("chroma_sample_location", null, "chroma_sample_location", OTE, new AVOptionValue(AVChromaLocation.AVCHROMA_LOC_UNSPECIFIED), 0, AVChromaLocation.AVCHROMA_LOC_NB.ordinal()-1, V|E|D));
		cls.add_option(new AVOption("psy", "use psycho visual optimization", 0, OTC, new AVOptionValue(AVCodec.CODEC_FLAG2_PSY), MIN, MAX, V|E, "flags2"));
		cls.add_option(new AVOption("psy_rd", "specify psycho visual strength", "psy_rd", OTFl, new AVOptionValue(Float.valueOf((float)1.0)), 0, FLT_MAX, V|E));
		cls.add_option(new AVOption("psy_trellis", "specify psycho visual trellis", "psy_trellis", OTFl, new AVOptionValue(Float.valueOf((float)0)), 0, FLT_MAX, V|E));
		cls.add_option(new AVOption("aq_mode", "specify aq method", "aq_mode", OTI, new AVOptionValue(1), 0, MAX, V|E));
		cls.add_option(new AVOption("aq_strength", "specify aq strength", "aq_strength", OTFl, new AVOptionValue(Float.valueOf((float)1.0)), 0, FLT_MAX, V|E));
		cls.add_option(new AVOption("rc_lookahead", "specify number of frames to look ahead for frametype", "rc_lookahead", OTI, new AVOptionValue(40), 0, MAX, V|E));
		cls.add_option(new AVOption("ssim", "ssim will be calculated during encoding", 0, OTC, new AVOptionValue(AVCodec.CODEC_FLAG2_SSIM), MIN, MAX, V|E, "flags2"));
		cls.add_option(new AVOption("intra_refresh", "use periodic insertion of intra blocks instead of keyframes", 0, OTC, new AVOptionValue(AVCodec.CODEC_FLAG2_INTRA_REFRESH), MIN, MAX, V|E, "flags2"));
		cls.add_option(new AVOption("crf_max", "in crf mode, prevents vbv from lowering quality beyond this point", "crf_max", OTFl, new AVOptionValue(Float.valueOf((float)DEFAULT)), 0, 51, V|E));
		cls.add_option(new AVOption("log_level_offset", "set the log level offset", "log_level_offset", OTI, new AVOptionValue(0), MIN, MAX));
		cls.add_option(new AVOption("slices", "number of slices, used in parallelized decoding", "slices", OTI, new AVOptionValue(0), 0, MAX, V|E));
		cls.add_option(new AVOption("thread_type", "select multithreading type", "thread_type", OTI, new AVOptionValue(AVCodec.FF_THREAD_SLICE|AVCodec.FF_THREAD_FRAME), 0, MAX, V|E|D, "thread_type"));
		cls.add_option(new AVOption("slice", null, 0, OTC, new AVOptionValue(AVCodec.FF_THREAD_SLICE), MIN, MAX, V|E|D, "thread_type"));
		cls.add_option(new AVOption("frame", null, 0, OTC, new AVOptionValue(AVCodec.FF_THREAD_FRAME), MIN, MAX, V|E|D, "thread_type"));
		cls.add_option(new AVOption("vbv_delay", "initial buffer fill time in periods of 27Mhz clock", null, OTI64, new AVOptionValue(Long.valueOf(0)), 0, INT64_MAX));
		cls.add_option(new AVOption("audio_service_type", "audio service type", "audio_service_type", OTE, new AVOptionValue(AVAudioServiceType.AV_AUDIO_SERVICE_TYPE_MAIN), 0, AVAudioServiceType.AV_AUDIO_SERVICE_TYPE_NB.ordinal()-1, A|E, "audio_service_type"));
		cls.add_option(new AVOption("ma", "Main Audio Service", 0, OTC, new AVOptionValue(AVAudioServiceType.AV_AUDIO_SERVICE_TYPE_MAIN),              MIN, MAX, A|E, "audio_service_type"));
		cls.add_option(new AVOption("ef", "Effects",            0, OTC, new AVOptionValue(AVAudioServiceType.AV_AUDIO_SERVICE_TYPE_EFFECTS),           MIN, MAX, A|E, "audio_service_type"));
		cls.add_option(new AVOption("vi", "Visually Impaired",  0, OTC, new AVOptionValue(AVAudioServiceType.AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED), MIN, MAX, A|E, "audio_service_type"));
		cls.add_option(new AVOption("hi", "Hearing Impaired",   0, OTC, new AVOptionValue(AVAudioServiceType.AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED),  MIN, MAX, A|E, "audio_service_type"));
		cls.add_option(new AVOption("di", "Dialogue",           0, OTC, new AVOptionValue(AVAudioServiceType.AV_AUDIO_SERVICE_TYPE_DIALOGUE),          MIN, MAX, A|E, "audio_service_type"));
		cls.add_option(new AVOption("co", "Commentary",         0, OTC, new AVOptionValue(AVAudioServiceType.AV_AUDIO_SERVICE_TYPE_COMMENTARY),        MIN, MAX, A|E, "audio_service_type"));
		cls.add_option(new AVOption("em", "Emergency",          0, OTC, new AVOptionValue(AVAudioServiceType.AV_AUDIO_SERVICE_TYPE_EMERGENCY),         MIN, MAX, A|E, "audio_service_type"));
		cls.add_option(new AVOption("vo", "Voice Over",         0, OTC, new AVOptionValue(AVAudioServiceType.AV_AUDIO_SERVICE_TYPE_VOICE_OVER),        MIN, MAX, A|E, "audio_service_type"));
		cls.add_option(new AVOption("ka", "Karaoke",            0, OTC, new AVOptionValue(AVAudioServiceType.AV_AUDIO_SERVICE_TYPE_KARAOKE),           MIN, MAX, A|E, "audio_service_type"));
		cls.add_option(new AVOption("request_sample_fmt", "sample format audio decoders should prefer", "request_sample_fmt", OTE, new AVOptionValue(AVSampleFormat.AV_SAMPLE_FMT_NONE), AVSampleFormat.AV_SAMPLE_FMT_NONE.ordinal(), AVSampleFormat.AV_SAMPLE_FMT_NB.ordinal()-1, A|D, "request_sample_fmt"));
		cls.add_option(new AVOption("u8" , "8-bit unsigned integer", 0, OTC, new AVOptionValue(AVSampleFormat.AV_SAMPLE_FMT_U8), MIN, MAX, A|D, "request_sample_fmt"));
		cls.add_option(new AVOption("s16", "16-bit signed integer",  0, OTC, new AVOptionValue(AVSampleFormat.AV_SAMPLE_FMT_S16), MIN, MAX, A|D, "request_sample_fmt"));
		cls.add_option(new AVOption("s32", "32-bit signed integer",  0, OTC, new AVOptionValue(AVSampleFormat.AV_SAMPLE_FMT_S32), MIN, MAX, A|D, "request_sample_fmt"));
		cls.add_option(new AVOption("flt", "32-bit float",           0, OTC, new AVOptionValue(AVSampleFormat.AV_SAMPLE_FMT_FLT), MIN, MAX, A|D, "request_sample_fmt"));
		cls.add_option(new AVOption("dbl", "64-bit double",          0, OTC, new AVOptionValue(AVSampleFormat.AV_SAMPLE_FMT_DBL), MIN, MAX, A|D, "request_sample_fmt"));

}
	
}
